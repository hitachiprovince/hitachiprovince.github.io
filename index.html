<!DOCTYPE html>
<html>
<head>
  <title>Roleplay Map ‚Äî Live JSON Map</title>
  <meta charset="utf-8" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 8px;
      font-family: sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      /* Admin controls are still hidden initially, but they only affect the current session */
      display: none; 
      z-index: 1000;
    }
    button {
      margin: 2px;
      cursor: pointer;
    }
    #adminNotice {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 13px;
      display: none;
      z-index: 1000;
    }
  </style>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <button id="addPinBtn">‚ûï Add Pin</button>
    <button id="removePinBtn">üóë Remove Pin</button>
    <button id="colorBtn">üé® Color Mode</button>
    <input type="color" id="colorPicker" value="#ffcc00" style="display:none;">
    <button id="exportBtn">‚¨áÔ∏è Export to File</button>
    <span style="margin-left:8px; opacity:0.7;">Admin mode active (Changes will not be saved permanently)</span>
  </div>
  <div id="adminNotice">Admin mode enabled</div>

  <script>
    const MAP_SOURCE_FILE = 'roleplay_map_export.json';

    const map = L.map('map', {
      crs: L.CRS.Simple,
      minZoom: -1,
      maxZoom: 2,
    });

    const mapWidth = 2000;
    const mapHeight = 1500;
    const bounds = [[0, 0], [mapHeight, mapWidth]];

    let svgElement = null;
    let currentColors = {}; // Holds temporary colors for the current session
    let mode = "none";
    let markers = [];
    let isAdmin = false;

    // --- Core Loading Logic: Loads ONLY from the JSON file ---
    function loadMap(pinsData, colorsData, svgText) {
      // 1. Load SVG
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
      svgElement = svgDoc.documentElement;

      map.eachLayer(layer => {
        if (layer instanceof L.SVGOverlay) {
          map.removeLayer(layer);
        }
      });
      
      const svgOverlay = L.svgOverlay(svgElement, bounds).addTo(map);
      map.fitBounds(bounds);

      // 2. Load Coloring (Uses colors from JSON, or falls back to an empty object)
      currentColors = colorsData || {};
      enableColoring(svgElement);
      
      // 3. Load Pins (Uses pins from JSON)
      markers.forEach(m => map.removeLayer(m));
      markers = [];

      const dataToLoad = pinsData || [];
      dataToLoad.forEach(p => {
        const m = L.marker(p.latlng).addTo(map);
        m.bindPopup(p.text);
        markers.push(m);
      });
    }
    
    // --- Automatic File Fetch and Map Initialization ---
    fetch(MAP_SOURCE_FILE)
        .then(res => {
            if (!res.ok) {
                console.error(`Error: Could not find or access the map file "${MAP_SOURCE_FILE}".`);
                // Fallback to try loading a default SVG without any data
                return fetch('drawing2.svg').then(res => res.text()).then(svgText => loadMap([], {}, svgText));
            }
            return res.json();
        })
        .then(data => {
            if (typeof data === 'string') return; // Handled error fallback
            
            // Success: Load map using data from the JSON file
            loadMap(data.pins, data.colors, data.svg);
        })
        .catch(error => {
            console.error("Critical error during map initialization:", error);
            alert("The map could not be loaded from the JSON file.");
        });


    // --- Admin UI & Handlers --- 
    const controls = document.getElementById("controls");
    const adminNotice = document.getElementById("adminNotice");
    const colorBtn = document.getElementById("colorBtn");
    const colorPicker = document.getElementById("colorPicker");
    const exportBtn = document.getElementById("exportBtn");
    
    document.getElementById("addPinBtn").onclick = () => {
      mode = "add";
      map.getContainer().style.cursor = "crosshair";
    };
    document.getElementById("removePinBtn").onclick = () => {
      mode = "remove";
      map.getContainer().style.cursor = "not-allowed";
    };
    colorBtn.onclick = () => {
      if (!isAdmin) return;
      mode = "color";
      colorPicker.style.display = "inline-block";
      map.getContainer().style.cursor = "pointer";
    };
    exportBtn.onclick = exportMapData; 


    // --- Map click behavior ---
    map.on("click", e => { 
      if (!isAdmin) return; 
      if (mode === "add") { 
        const text = prompt("Enter description for this pin:"); 
        if (text !== null) { 
          const m = L.marker(e.latlng).addTo(map); 
          m.bindPopup(text); 
          markers.push(m); 
          // Pin changes saved to markers array, but NOT to localStorage
        } 
      } 
      if (mode !== "color") {
        mode = "none"; 
        map.getContainer().style.cursor = ""; 
        colorPicker.style.display = "none"; 
      }
    }); 

    // --- Popup Edit/Delete only for Admin ---
    map.on("popupopen", e => { 
      if (!isAdmin) return; 
      const marker = e.popup._source; 
      const popupEl = e.popup.getElement(); 
      if (!popupEl.querySelector(".popup-controls")) { 
        const div = document.createElement("div"); 
        div.className = "popup-controls"; 
        div.innerHTML = ` 
          <hr> 
          <button class="edit">‚úè Edit</button> 
          <button class="delete">üóë Delete</button> 
        `; 
        popupEl.querySelector(".leaflet-popup-content").appendChild(div); 

        div.querySelector(".edit").onclick = () => { 
          const currentText = marker.getPopup().getContent().split("<hr>")[0].trim();
          const newText = prompt("Edit pin text:", currentText); 
          if (newText !== null) { 
            marker.bindPopup(newText).openPopup(); 
            // Pin changes saved to markers array, but NOT to localStorage
          } 
        }; 

        div.querySelector(".delete").onclick = () => { 
          map.removeLayer(marker); 
          markers = markers.filter(m => m !== marker); 
          // Pin changes saved to markers array, but NOT to localStorage
        }; 
      } 
    }); 

    function getPinsData() {
        return markers.map(m => ({ 
            latlng: m.getLatLng(), 
            text: m.getPopup().getContent().split("<hr>")[0].trim(), 
        }));
    }

    // savePins function removed, as state should not be saved

    // --- Hidden admin activation ---
    let keySequence = []; 
    const secret = "admin"; 

    window.addEventListener("keydown", e => { 
      keySequence.push(e.key.toLowerCase()); 
      if (keySequence.join("").includes(secret)) { 
        enableAdmin(); 
        keySequence = []; 
      } 
      if (keySequence.length > 10) keySequence.shift(); 
    }); 

    function enableAdmin() { 
      // NOTE: Change "yourpassword" to a secure password!
      const password = prompt("Enter admin password:"); 
      if (password === "iksdehitachi") { 
        isAdmin = true; 
        controls.style.display = "block"; 
        adminNotice.style.display = "block"; 
        setTimeout(() => adminNotice.style.display = "none", 2500); 
      } else { 
        alert("Incorrect password"); 
      } 
    } 

    // --- Province coloring ---
    function enableColoring(svgRoot) { 
      const colorableElements = svgRoot.querySelectorAll("path, polygon, g[id]"); 
       
      colorableElements.forEach(el => { 
        if (el.id) { 
            if (!el.style.fill || el.style.fill === 'none') { 
                el.style.fill = 'transparent';  
            } 
            el.style.pointerEvents = 'all'; 
        } 
      }); 

      // Apply initial colors loaded from the JSON file
      for (const [id, color] of Object.entries(currentColors)) { 
        const el = svgRoot.querySelector(`#${CSS.escape(id)}`); 
        if (el) el.style.fill = color; 
      } 

      svgRoot.addEventListener("click", (ev) => { 
        if (!isAdmin || mode !== "color") return; 

        const target = ev.target; 
        const isColorableTag = (target.tagName === "path" || target.tagName === "polygon" || target.tagName === "g"); 
         
        if (!isColorableTag || !target.id) return;  

        const color = colorPicker.value; 
        target.style.fill = color; 
         
        // Update the current in-session colors, but NOT localStorage
        currentColors[target.id] = color; 
      }); 
    }
    
    // --- Export Functionality ---

    function exportMapData() {
        if (!svgElement) return alert("Map SVG not loaded yet!");

        // Get the current in-session pin and color data
        const pinsData = getPinsData();
        const colorsData = currentColors; 

        // 1. Clone the SVG element to modify styles for export
        const svgClone = svgElement.cloneNode(true);
        
        // 2. Apply all current in-session colors directly into the cloned SVG's style attribute
        for (const [id, color] of Object.entries(colorsData)) { 
            const el = svgClone.querySelector(`#${CSS.escape(id)}`); 
            if (el) el.style.fill = color; 
        } 
        
        // 3. Create the final data object
        const exportObject = {
            version: "1.0", 
            svg: svgClone.outerHTML,
            pins: pinsData,
            colors: colorsData 
        };

        const jsonString = JSON.stringify(exportObject, null, 2);
        
        // 4. Trigger download with fixed filename
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = MAP_SOURCE_FILE; 
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>