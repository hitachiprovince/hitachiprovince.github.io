<!DOCTYPE html>
<html>
<head>
  <title>Roleplay Map ‚Äî Admin Mode + Coloring</title>
  <meta charset="utf-8" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 8px;
      font-family: sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      display: none;
    }
    button {
      margin: 2px;
      cursor: pointer;
    }
    #adminNotice {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 13px;
      display: none;
    }
  </style>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <button id="addPinBtn">‚ûï Add Pin</button>
    <button id="removePinBtn">üóë Remove Pin</button>
    <button id="colorBtn">üé® Color Mode</button>
    <input type="color" id="colorPicker" value="#ffcc00" style="display:none;">
    <span style="margin-left:8px; opacity:0.7;">Admin mode active</span>
  </div>
  <div id="adminNotice">Admin mode enabled</div>

  <script>
    const map = L.map('map', {
      crs: L.CRS.Simple,
      minZoom: -1,
      maxZoom: 2,
    });

    const mapWidth = 2000;
    const mapHeight = 1500;
    const bounds = [[0, 0], [mapHeight, mapWidth]];

    // Load the SVG file dynamically so we can interact with it
    fetch('drawing2.svg')
      .then(res => res.text())
      .then(svgText => {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
        const svgElement = svgDoc.documentElement;

        // Make sure it fits Leaflet coordinate system
        const svgOverlay = L.svgOverlay(svgElement, bounds).addTo(map);
        map.fitBounds(bounds);

        enableColoring(svgElement);
      });

    let mode = "none";
    let markers = [];
    let isAdmin = false;

    // Load pins
    const saved = JSON.parse(localStorage.getItem('pins') || '[]');
    saved.forEach(p => {
      const m = L.marker(p.latlng).addTo(map);
      m.bindPopup(p.text);
      markers.push(m);
    });

    // --- Admin UI ---
    const controls = document.getElementById("controls");
    const adminNotice = document.getElementById("adminNotice");
    const colorBtn = document.getElementById("colorBtn");
    const colorPicker = document.getElementById("colorPicker");

    document.getElementById("addPinBtn").onclick = () => {
      mode = "add";
      map.getContainer().style.cursor = "crosshair";
    };
    document.getElementById("removePinBtn").onclick = () => {
      mode = "remove";
      map.getContainer().style.cursor = "not-allowed";
    };
    colorBtn.onclick = () => {
      if (!isAdmin) return;
      mode = "color";
      colorPicker.style.display = "inline-block";
      map.getContainer().style.cursor = "pointer";
    };

    // --- Map click behavior ---
    map.on("click", e => {
      if (!isAdmin) return;
      if (mode === "add") {
        const text = prompt("Enter description for this pin:");
        if (text !== null) {
          const m = L.marker(e.latlng).addTo(map);
          m.bindPopup(text);
          markers.push(m);
          savePins();
        }
      }
      mode = "none";
      map.getContainer().style.cursor = "";
    });

    // --- Popup Edit/Delete only for Admin ---
    map.on("popupopen", e => {
      if (!isAdmin) return;
      const marker = e.popup._source;
      const popupEl = e.popup.getElement();
      if (!popupEl.querySelector(".popup-controls")) {
        const div = document.createElement("div");
        div.className = "popup-controls";
        div.innerHTML = `
          <hr>
          <button class="edit">‚úè Edit</button>
          <button class="delete">üóë Delete</button>
        `;
        popupEl.querySelector(".leaflet-popup-content").appendChild(div);

        div.querySelector(".edit").onclick = () => {
          const newText = prompt("Edit pin text:", marker.getPopup().getContent().split("<hr>")[0]);
          if (newText !== null) {
            marker.bindPopup(newText).openPopup();
            savePins();
          }
        };

        div.querySelector(".delete").onclick = () => {
          map.removeLayer(marker);
          markers = markers.filter(m => m !== marker);
          savePins();
        };
      }
    });

    function savePins() {
      const data = markers.map(m => ({
        latlng: m.getLatLng(),
        text: m.getPopup().getContent().split("<hr>")[0],
      }));
      localStorage.setItem("pins", JSON.stringify(data));
    }

    // --- Hidden admin activation ---
    let keySequence = [];
    const secret = "admin";

    window.addEventListener("keydown", e => {
      keySequence.push(e.key.toLowerCase());
      if (keySequence.join("").includes(secret)) {
        enableAdmin();
        keySequence = [];
      }
      if (keySequence.length > 10) keySequence.shift();
    });

    function enableAdmin() {
      const password = prompt("Enter admin password:");
      if (password === "iksdehitachi") {
        isAdmin = true;
        controls.style.display = "block";
        adminNotice.style.display = "block";
        setTimeout(() => adminNotice.style.display = "none", 2500);
      } else {
        alert("Incorrect password");
      }
    }

    // --- Province coloring ---
    // --- Province coloring ---
// --- Province coloring ---
function enableColoring(svgRoot) {
  const savedColors = JSON.parse(localStorage.getItem("provinceColors") || "{}");
  const colorableElements = svgRoot.querySelectorAll("path, polygon, g[id]");
  
  // 1. Dynamic Styling Fix: Make all elements click-targetable
  colorableElements.forEach(el => {
    // Ensure the element has an ID and is not already colored
    if (el.id) {
        // Set fill and pointer-events so clicks register on the transparent area
        if (!el.style.fill || el.style.fill === 'none') {
            el.style.fill = 'transparent'; 
        }
        el.style.pointerEvents = 'all';
    }
  });

  // Restore saved colors (must be done after potentially setting fill to 'transparent')
  for (const [id, color] of Object.entries(savedColors)) {
    const el = svgRoot.querySelector(`#${CSS.escape(id)}`);
    if (el) el.style.fill = color;
  }

  svgRoot.addEventListener("click", (ev) => {
    if (!isAdmin || mode !== "color") return;

    const target = ev.target;
    
    // Check if the clicked element is an SVG graphical element (path, polygon) or a grouping element (g)
    const isColorableTag = (target.tagName === "path" || target.tagName === "polygon" || target.tagName === "g");
    
    if (!isColorableTag) return;
    
    // Crucial check: only color/save elements that have a unique ID
    if (!target.id) return; 

    const color = colorPicker.value;
    target.style.fill = color;
    
    savedColors[target.id] = color;
    localStorage.setItem("provinceColors", JSON.stringify(savedColors));
  });
}
  </script>
</body>
</html>

